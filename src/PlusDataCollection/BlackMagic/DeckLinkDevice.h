/* -LICENSE-START-
** Copyright (c) 2013 Blackmagic Design
**
** Permission is hereby granted, free of charge, to any person or organization
** obtaining a copy of the software and accompanying documentation covered by
** this license (the "Software") to use, reproduce, display, distribute,
** execute, and transmit the Software, and to prepare derivative works of the
** Software, and to permit third-parties to whom the Software is furnished to
** do so, all subject to the following:
**
** The copyright notices in the Software and this entire statement, including
** the above license grant, this restriction and the following disclaimer,
** must be included in all copies of the Software, in whole or in part, and
** all derivative works of the Software, unless such copies or derivative
** works are solely in the form of machine-executable object code generated by
** a source language processor.
**
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
** DEALINGS IN THE SOFTWARE.
** -LICENSE-END-
*/

// STL includes
#include <vector>

// DeckLink SDK includes
#define _stringify(x) #x
#define STRINGIFY(x) _stringify(x)
#if WIN32
  #include <combaseapi.h>
#endif
#include STRINGIFY(DeckLinkSDK_INCLUDE_FILE)
#undef STRINGIFY
#undef _stringify

typedef struct
{
  // VITC timecodes and user bits for field 1 & 2
  std::string vitcF1Timecode;
  std::string vitcF1UserBits;
  std::string vitcF2Timecode;
  std::string vitcF2UserBits;

  // RP188 timecodes and user bits (VITC1, VITC2, LTC and HFRTC)
  std::string rp188vitc1Timecode;
  std::string rp188vitc1UserBits;
  std::string rp188vitc2Timecode;
  std::string rp188vitc2UserBits;
  std::string rp188ltcTimecode;
  std::string rp188ltcUserBits;
  std::string rp188hfrtcTimecode;
  std::string rp188hfrtcUserBits;
} AncillaryDataStruct;

typedef struct
{
  std::string electroOpticalTransferFunction;
  std::string displayPrimariesRedX;
  std::string displayPrimariesRedY;
  std::string displayPrimariesGreenX;
  std::string displayPrimariesGreenY;
  std::string displayPrimariesBlueX;
  std::string displayPrimariesBlueY;
  std::string whitePointX;
  std::string whitePointY;
  std::string maxDisplayMasteringLuminance;
  std::string minDisplayMasteringLuminance;
  std::string maximumContentLightLevel;
  std::string maximumFrameAverageLightLevel;
  std::string colorspace;
} HDRMetadataStruct;

class DeckLinkDevice : public IDeckLinkInputCallback
{
private:
  unsigned long               m_refCount;

  std::string                 m_deviceName;
  IDeckLink*                  m_deckLink;
  IDeckLinkInput*             m_deckLinkInput;
  IDeckLinkConfiguration*     m_deckLinkConfig;
  IDeckLinkHDMIInputEDID*     m_deckLinkHDMIInputEDID;
  IDeckLinkProfileManager*    m_deckLinkProfileManager;
  IDeckLinkProfileAttributes* m_deckLinkAttributes;

  bool                        m_supportsFormatDetection;
  bool                        m_currentlyCapturing;
  bool                        m_applyDetectedInputMode;

  static void                 GetAncillaryDataFromFrame(IDeckLinkVideoInputFrame* frame, BMDTimecodeFormat format, std::string& timecodeString, std::string& userBitsString);
  static void                 GetHDRMetadataFromFrame(IDeckLinkVideoInputFrame* videoFrame, HDRMetadataStruct& hdrMetadata);

public:
  DeckLinkDevice(IDeckLink* device);
  virtual ~DeckLinkDevice();

  bool                        Init();
  std::string                 GetDeviceName();;
  bool                        IsCapturing();;
  bool                        SupportsFormatDetection();;
  bool                        StartCapture(BMDDisplayMode displayMode, IDeckLinkScreenPreviewCallback* screenPreviewCallback, bool applyDetectedInputMode);
  void                        StopCapture();
  IDeckLink*                  DeckLinkInstance();
  IDeckLinkProfileManager*    GetDeviceProfileManager();;
  IDeckLinkInput*             GetDeckLinkInput();;
  IDeckLinkConfiguration*     GetDeckLinkConfiguration();;
  IDeckLinkProfileAttributes* GetDeckLinkAttributes();;

  // IDeckLinkInputCallback interface
  virtual HRESULT STDMETHODCALLTYPE VideoInputFormatChanged(BMDVideoInputFormatChangedEvents notificationEvents, IDeckLinkDisplayMode* newDisplayMode, BMDDetectedVideoInputFormatFlags detectedSignalFlags);
  virtual HRESULT STDMETHODCALLTYPE VideoInputFrameArrived(IDeckLinkVideoInputFrame* videoFrame, IDeckLinkAudioInputPacket* audioPacket);

  // IUnknown
  virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID iid, LPVOID* ppv);
  virtual ULONG STDMETHODCALLTYPE AddRef();
  virtual ULONG STDMETHODCALLTYPE Release();
};

class DeckLinkDeviceDiscovery :  public IDeckLinkDeviceNotificationCallback
{
public:
  DeckLinkDeviceDiscovery();
  virtual ~DeckLinkDeviceDiscovery();

  bool Enable();
  void Disable();

  // IDeckLinkDeviceNotificationCallback interface
  virtual HRESULT STDMETHODCALLTYPE DeckLinkDeviceArrived(IDeckLink* deckLink);
  virtual HRESULT STDMETHODCALLTYPE DeckLinkDeviceRemoved(IDeckLink* deckLink);

  // IUnknown needs only a dummy implementation
  virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID iid, LPVOID* ppv);
  virtual ULONG STDMETHODCALLTYPE AddRef();
  virtual ULONG STDMETHODCALLTYPE Release();

private:
  IDeckLinkDiscovery*   m_deckLinkDiscovery;
  unsigned long         m_refCount;
};
